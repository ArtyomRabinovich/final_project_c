#ifndef MYFUNCTION_H
#define MYFUNCTION_H

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

#define BUFF_SIZE 256
#define blue() printf("\033[0;34m")
#define reset() printf("\033[0m")
#define green() printf("\033[0;32m")
#define bold() printf("\e[1m")
#define boldOff() printf("\e[m")

/**
 * Reads a string from the standard input (stdin) until a newline character is encountered.
 *
 * This function dynamically allocates memory to store the input string, including
 * space for the null terminator. The caller is responsible for freeing this memory
 * when it is no longer needed.
 *
 * @return A pointer to the dynamically allocated string containing the user input,
 *         excluding the newline character. Returns NULL if memory allocation fails.
 *
 * @warning The caller is responsible for freeing the memory allocated for the
 *          returned string using free().
 */
char *getInputFromUser(void);

/**
 * Custom string tokenizer that supports consecutive delimiters and remembers the
 * state between calls.
 *
 * This function is similar to the standard strtok function but supports consecutive
 * delimiters and uses a static variable to remember the state between calls. It can
 * be used to tokenize a string by repeatedly calling this function until NULL is
 * returned.
 *
 * @param str The string to tokenize on the first call. Subsequent calls should pass
 *            NULL as this parameter to continue tokenizing the same string.
 * @param delim A null-terminated string containing the delimiter characters.
 *
 * @return On success, returns a pointer to the next token found in the string. Returns
 *         NULL if there are no more tokens or if `str` is NULL on the first call.
 */
char *myStrtok(char *str, const char *delim);

/**
 * Splits a string into individual tokens based on whitespace.
 *
 * This function takes a string as input and tokenizes it based on whitespace
 * characters (space, tab, newline). It dynamically allocates memory for an
 * array of strings to store the tokens. The caller is responsible for freeing
 * the memory allocated for the array and its elements when it's no longer needed.
 *
 * @param input A pointer to the string to be split.
 *
 * @return A dynamically allocated array of strings (char**) containing the tokens.
 *         The last element of the array is NULL. Returns NULL if input is NULL
 *         or if memory allocation fails.
 *
 * @note The input string will be modified (tokenized) by this function.
 *       Make sure to use a copy of the original string if preservation
 *       of the original string is required.
 *
 * @warning The caller is responsible for freeing the memory allocated for
 *          the returned array and its elements using free().
 */
char **splitArgument(char *input);

/**
 * Retrieves and prints the current working directory to standard output.
 *
 * This function attempts to obtain the current working directory path and prints
 * it to the standard output. If successful, the directory path is followed by a
 * dollar sign ('$'). If an error occurs, an error message is printed instead.
 *
 * @warning This function does not return the directory path but prints it directly
 *          to the standard output.
 */
void getLocation(void);
/**
 * Prints a welcome message to the standard output.
 *
 * This function displays a welcome message along with ASCII art and additional
 * information such as a GitHub repository link and a quote. It is intended to
 * be called at the start of the program to greet the user.
 */
void welcome(void);

/**
 * Processes the 'logout' command by terminating the program if the user inputs 'exit'.
 *
 * This function checks if the first token of the user input is 'exit'. If so, it
 * terminates the program. Otherwise, it prints a message indicating that the command
 * is not recognized. It also handles memory cleanup for the tokens generated by
 * splitArgument.
 *
 * @param str A string containing the user input to be processed.
 */
void logout(char *str);

/**
 * Changes the current working directory to the one specified by the user.
 *
 * This function attempts to change the current working directory to the path
 * specified in the `args` array. If the path is not provided or the change
 * directory operation fails, it prints an appropriate message to the standard output.
 *
 * @param args An array of strings representing the command and its arguments. The
 *             first element is assumed to be "cd" and the second element is the
 *             path to change to.
 */
void cd(char **args);

/**
 * Copies a file from a source path to a destination path.
 *
 * This function copies the contents of the file located at the source path to
 * a new file at the destination path. If any of the paths are not provided or
 * an error occurs during the copying process, it prints an appropriate message
 * to the standard output.
 *
 * @param args An array of strings where the first element is the command, the
 *             second element is the source file path, and the third element is
 *             the destination file path.
 */
void cp(char **args);

/**
 * Deletes the file at the specified path.
 *
 * This function attempts to delete the file located at the path specified in the
 * `args` array. If the path is not provided or the deletion fails, it prints an
 * appropriate message to the standard output.
 *
 * @param args An array of strings where the first element is the command and the
 *             second element is the path of the file to be deleted.
 */
void delete(char *input);

/**
 * Implements a simple pipe between two commands.
 *
 * This function creates a UNIX pipe and forks two processes to execute the
 * specified commands, where the output of the first command (argv1) is piped
 * into the input of the second command (argv2).
 *
 * @param argv1 An array of strings representing the first command and its arguments.
 * @param argv2 An array of strings representing the second command and its arguments.
 */
void mypipe(char **argv1, char **argv2);

/**
 * Moves a file from a source path to a destination path.
 *
 * This function renames the file located at the source path to the destination
 * path, effectively moving it. If any of the paths are not provided or the move
 * operation fails, it prints an appropriate message to the standard output.
 *
 * @param args An array of strings where the first element is the command, the
 *             second element is the source file path, and the third element is
 *             the destination file path.
 */
void move(char **args);
/**
 * Appends a string to a file.
 *
 * This function appends the given string (before the ">>" symbol in `args`)
 * to the file specified after the ">>" symbol in `args`. If the file cannot
 * be opened or the ">>" symbol is not found, it prints an appropriate error message.
 *
 * @param args An array of strings containing the command, the string to append,
 *             the ">>" symbol, and the file path.
 */
void echoppend(char **args);

/**
 * Writes (overwrites) a string to a file.
 *
 * This function writes the given string (before the ">" symbol in `args`) to
 * the file specified after the ">" symbol in `args`, overwriting any existing
 * content. If the file cannot be opened or the ">" symbol is not found, it prints
 * an appropriate error message.
 *
 * @param args An array of strings containing the command, the string to write,
 *             the ">" symbol, and the file path.
 */
void echorite(char **args);

char *normalizePath(char *path);

char** splitOnPipe(const char* command);

void readFromStdin(char **args);

void writeToStdout(char **args);

char* trim(char* str);

/**
 * Displays the content of a file to the standard output.
 *
 * This function reads and prints the content of the file specified in `args`
 * to the standard output. If the file cannot be opened, it silently fails.
 *
 * @param args An array of strings where the first element is the command and the
 *             second element is the path of the file to read.
 */
void readI(char **args);
/**
 * Counts the words in a file and returns the count.
 *
 * This function opens the file specified by the `file` parameter and counts
 * the number of words contained within, using whitespace as the delimiter.
 * The file is closed before returning.
 *
 * @param file A pointer to an open file from which to count words.
 * @return The number of words in the file.
 */
int countWords(FILE *file);

/**
 * Counts the lines in a file and returns the count.
 *
 * This function opens the file specified by the `file` parameter and counts
 * the number of lines contained within. The file is closed before returning.
 *
 * @param file A pointer to an open file from which to count lines.
 * @return The number of lines in the file.
 */
int countLines(FILE *file);

/**
 * Counts words or lines in a file, based on the specified option.
 *
 * This function counts either the number of words or the number of lines in
 * the file specified in `args`, based on whether the "-w" (words) or "-l"
 * (lines) option is provided as the first argument.
 *
 * @param args An array of strings containing the command, the option ("-w" or "-l"),
 *             and the path of the file to process.
 */
void wordCount(char **args);

/**
 * Displays a list of available commands and their descriptions.
 *
 * This function prints a help message to the standard output, listing all
 * the available commands supported by the shell along with a brief description
 * of what each command does. It's intended to assist users in understanding the
 * functionality of the shell and how to use its commands effectively.
 *
 * Usage:
 *   help
 *
 * Example:
 *   > help
 *   Available commands:
 *     cd <directory> - Change the current directory to <directory>
 *     cp <source> <destination> - Copy <source> to <destination>
 *     delete <file> - Delete <file>
 *     ... and so on for each command ...
 *
 * Note:
 *   This command does not require any arguments. Typing 'help' will display
 *   the list of commands.
 */
void help(void);

#endif // MYFUNCTION_H
